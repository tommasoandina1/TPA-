#include <iostream>
#include <fstream>
#include <vector>
#include <stdexcept>
#include <omp.h>

using namespace std;

template<typename T>
class Matrix {
private:
    vector<vector<T>> data;
    int rows, cols;

public:
    Matrix(int r = 0, int c = 0) : rows(r), cols(c), data(r, vector<T>(c, 0)) {}

    int getRows() const { return rows; }
    int getColumns() const { return cols; }
    T getValue(int r, int c) const { return data[r][c]; }
    void setValue(int r, int c, T value) { data[r][c] = value; }

    bool readFromFile(const string& filename);
    void writeToFile(const string& filename) const;
    Matrix<T> convolution(const Matrix<T>& kernel) const;
};

template<typename T>
bool Matrix<T>::readFromFile(const string& filename) {
    ifstream file(filename);
    if (!file) {
        cerr << "Could not open file " << filename << endl;
        return false;
    }

    for (int i = 0; i < rows; ++i) {
        for (int j = 0; j < cols; ++j) {
            file >> data[i][j];
        }
    }
    file.close();
    return true;
}

template<typename T>
void Matrix<T>::writeToFile(const string& filename) const {
    ofstream file(filename);
    if (!file) {
        cerr << "Could not open file " << filename << endl;
        return;
    }

    for (int i = 0; i < rows; ++i) {
        for (int j = 0; j < cols; ++j) {
            file << data[i][j] << " ";
        }
        file << endl;
    }
    file.close();
}

template<typename T>
Matrix<T> Matrix<T>::convolution(const Matrix<T>& kernel) const {
    int outputRows = rows - kernel.rows + 1;
    int outputCols = cols - kernel.cols + 1;
    Matrix<T> output(outputRows, outputCols);

    #pragma omp parallel for collapse(2)
    for (int i = 0; i < outputRows; ++i) {
        for (int j = 0; j < outputCols; ++j) {
            T sum = 0;
            for (int ki = 0; ki < kernel.rows; ++ki) {
                for (int kj = 0; kj < kernel.cols; ++kj) {
                    sum += this->getValue(i + ki, j + kj) * kernel.getValue(ki, kj);
                }
            }
            output.setValue(i, j, sum);
        }
    }

    return output;
}




int main() {
        int inputSize = 1000;
        int kernelSize = 4;

        Matrix<float> input(inputSize, inputSize);
        Matrix<float> kernel(kernelSize, kernelSize);
        Matrix<float> output(inputSize - kernelSize + 1, inputSize - kernelSize + 1);
        
        

        
        double start_p, end_p;
        start_p = omp_get_wtime();
        for (size_t i = 0; i < 100; i++)
        {
        #pragma omp parallel sections
        {
            #pragma omp section
       
            {
                input.readFromFile("matrix.txt");
            }
            #pragma omp section
            {
               kernel.readFromFile("kernel.txt");
            }
        }

        output = input.convolution(kernel);
        output.writeToFile("output_matrix.txt");

    } 
        
    end_p = omp_get_wtime();
    printf("Tempo parallelo: %g\n", (end_p - start_p) / 100);
    return 0;

}
